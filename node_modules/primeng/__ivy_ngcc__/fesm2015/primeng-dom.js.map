{"version":3,"sources":["C:/Users/O N O M E/Desktop/Angular Project/MALL/node_modules/primeng/fesm2015/primeng-dom.js"],"names":[],"mappings":"AAAA","file":"primeng-dom.js","sourcesContent":["/**\n * @dynamic is for runtime initializing DomHandler.browser\n *\n * If delete below comment, we can see this error message:\n *  Metadata collected contains an error that will be reported at runtime:\n *  Only initialized variables and constants can be referenced\n *  because the value of this variable is needed by the template compiler.\n */\n// @dynamic\nclass DomHandler {\n    static addClass(element, className) {\n        if (element.classList)\n            element.classList.add(className);\n        else\n            element.className += ' ' + className;\n    }\n    static addMultipleClasses(element, className) {\n        if (element.classList) {\n            let styles = className.split(' ');\n            for (let i = 0; i < styles.length; i++) {\n                element.classList.add(styles[i]);\n            }\n        }\n        else {\n            let styles = className.split(' ');\n            for (let i = 0; i < styles.length; i++) {\n                element.className += ' ' + styles[i];\n            }\n        }\n    }\n    static removeClass(element, className) {\n        if (element.classList)\n            element.classList.remove(className);\n        else\n            element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n    }\n    static hasClass(element, className) {\n        if (element.classList)\n            return element.classList.contains(className);\n        else\n            return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\n    }\n    static siblings(element) {\n        return Array.prototype.filter.call(element.parentNode.children, function (child) {\n            return child !== element;\n        });\n    }\n    static find(element, selector) {\n        return Array.from(element.querySelectorAll(selector));\n    }\n    static findSingle(element, selector) {\n        if (element) {\n            return element.querySelector(selector);\n        }\n        return null;\n    }\n    static index(element) {\n        let children = element.parentNode.childNodes;\n        let num = 0;\n        for (var i = 0; i < children.length; i++) {\n            if (children[i] == element)\n                return num;\n            if (children[i].nodeType == 1)\n                num++;\n        }\n        return -1;\n    }\n    static indexWithinGroup(element, attributeName) {\n        let children = element.parentNode.childNodes;\n        let num = 0;\n        for (var i = 0; i < children.length; i++) {\n            if (children[i] == element)\n                return num;\n            if (children[i].attributes && children[i].attributes[attributeName] && children[i].nodeType == 1)\n                num++;\n        }\n        return -1;\n    }\n    static relativePosition(element, target) {\n        let elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : this.getHiddenElementDimensions(element);\n        const targetHeight = target.offsetHeight;\n        const targetOffset = target.getBoundingClientRect();\n        const viewport = this.getViewport();\n        let top, left;\n        if ((targetOffset.top + targetHeight + elementDimensions.height) > viewport.height) {\n            top = -1 * (elementDimensions.height);\n            if (targetOffset.top + top < 0) {\n                top = -1 * targetOffset.top;\n            }\n        }\n        else {\n            top = targetHeight;\n        }\n        if (elementDimensions.width > viewport.width) {\n            // element wider then viewport and cannot fit on screen (align at left side of viewport)\n            left = targetOffset.left * -1;\n        }\n        else if ((targetOffset.left + elementDimensions.width) > viewport.width) {\n            // element wider then viewport but can be fit on screen (align at right side of viewport)\n            left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;\n        }\n        else {\n            // element fits on screen (align with target)\n            left = 0;\n        }\n        element.style.top = top + 'px';\n        element.style.left = left + 'px';\n    }\n    static absolutePosition(element, target) {\n        let elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : this.getHiddenElementDimensions(element);\n        let elementOuterHeight = elementDimensions.height;\n        let elementOuterWidth = elementDimensions.width;\n        let targetOuterHeight = target.offsetHeight;\n        let targetOuterWidth = target.offsetWidth;\n        let targetOffset = target.getBoundingClientRect();\n        let windowScrollTop = this.getWindowScrollTop();\n        let windowScrollLeft = this.getWindowScrollLeft();\n        let viewport = this.getViewport();\n        let top, left;\n        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {\n            top = targetOffset.top + windowScrollTop - elementOuterHeight;\n            if (top < 0) {\n                top = windowScrollTop;\n            }\n        }\n        else {\n            top = targetOuterHeight + targetOffset.top + windowScrollTop;\n        }\n        if (targetOffset.left + elementOuterWidth > viewport.width)\n            left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);\n        else\n            left = targetOffset.left + windowScrollLeft;\n        element.style.top = top + 'px';\n        element.style.left = left + 'px';\n    }\n    static getHiddenElementOuterHeight(element) {\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        let elementHeight = element.offsetHeight;\n        element.style.display = 'none';\n        element.style.visibility = 'visible';\n        return elementHeight;\n    }\n    static getHiddenElementOuterWidth(element) {\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        let elementWidth = element.offsetWidth;\n        element.style.display = 'none';\n        element.style.visibility = 'visible';\n        return elementWidth;\n    }\n    static getHiddenElementDimensions(element) {\n        let dimensions = {};\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        dimensions.width = element.offsetWidth;\n        dimensions.height = element.offsetHeight;\n        element.style.display = 'none';\n        element.style.visibility = 'visible';\n        return dimensions;\n    }\n    static scrollInView(container, item) {\n        let borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');\n        let borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;\n        let paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');\n        let paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;\n        let containerRect = container.getBoundingClientRect();\n        let itemRect = item.getBoundingClientRect();\n        let offset = (itemRect.top + document.body.scrollTop) - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;\n        let scroll = container.scrollTop;\n        let elementHeight = container.clientHeight;\n        let itemHeight = this.getOuterHeight(item);\n        if (offset < 0) {\n            container.scrollTop = scroll + offset;\n        }\n        else if ((offset + itemHeight) > elementHeight) {\n            container.scrollTop = scroll + offset - elementHeight + itemHeight;\n        }\n    }\n    static fadeIn(element, duration) {\n        element.style.opacity = 0;\n        let last = +new Date();\n        let opacity = 0;\n        let tick = function () {\n            opacity = +element.style.opacity.replace(\",\", \".\") + (new Date().getTime() - last) / duration;\n            element.style.opacity = opacity;\n            last = +new Date();\n            if (+opacity < 1) {\n                (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);\n            }\n        };\n        tick();\n    }\n    static fadeOut(element, ms) {\n        var opacity = 1, interval = 50, duration = ms, gap = interval / duration;\n        let fading = setInterval(() => {\n            opacity = opacity - gap;\n            if (opacity <= 0) {\n                opacity = 0;\n                clearInterval(fading);\n            }\n            element.style.opacity = opacity;\n        }, interval);\n    }\n    static getWindowScrollTop() {\n        let doc = document.documentElement;\n        return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n    }\n    static getWindowScrollLeft() {\n        let doc = document.documentElement;\n        return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n    }\n    static matches(element, selector) {\n        var p = Element.prototype;\n        var f = p['matches'] || p.webkitMatchesSelector || p['mozMatchesSelector'] || p['msMatchesSelector'] || function (s) {\n            return [].indexOf.call(document.querySelectorAll(s), this) !== -1;\n        };\n        return f.call(element, selector);\n    }\n    static getOuterWidth(el, margin) {\n        let width = el.offsetWidth;\n        if (margin) {\n            let style = getComputedStyle(el);\n            width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n        }\n        return width;\n    }\n    static getHorizontalPadding(el) {\n        let style = getComputedStyle(el);\n        return parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);\n    }\n    static getHorizontalMargin(el) {\n        let style = getComputedStyle(el);\n        return parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    }\n    static innerWidth(el) {\n        let width = el.offsetWidth;\n        let style = getComputedStyle(el);\n        width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);\n        return width;\n    }\n    static width(el) {\n        let width = el.offsetWidth;\n        let style = getComputedStyle(el);\n        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);\n        return width;\n    }\n    static getInnerHeight(el) {\n        let height = el.offsetHeight;\n        let style = getComputedStyle(el);\n        height += parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);\n        return height;\n    }\n    static getOuterHeight(el, margin) {\n        let height = el.offsetHeight;\n        if (margin) {\n            let style = getComputedStyle(el);\n            height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n        }\n        return height;\n    }\n    static getHeight(el) {\n        let height = el.offsetHeight;\n        let style = getComputedStyle(el);\n        height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n        return height;\n    }\n    static getWidth(el) {\n        let width = el.offsetWidth;\n        let style = getComputedStyle(el);\n        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);\n        return width;\n    }\n    static getViewport() {\n        let win = window, d = document, e = d.documentElement, g = d.getElementsByTagName('body')[0], w = win.innerWidth || e.clientWidth || g.clientWidth, h = win.innerHeight || e.clientHeight || g.clientHeight;\n        return { width: w, height: h };\n    }\n    static getOffset(el) {\n        let rect = el.getBoundingClientRect();\n        return {\n            top: rect.top + document.body.scrollTop,\n            left: rect.left + document.body.scrollLeft\n        };\n    }\n    static replaceElementWith(element, replacementElement) {\n        let parentNode = element.parentNode;\n        if (!parentNode)\n            throw `Can't replace element`;\n        return parentNode.replaceChild(replacementElement, element);\n    }\n    static getUserAgent() {\n        return navigator.userAgent;\n    }\n    static isIE() {\n        var ua = window.navigator.userAgent;\n        var msie = ua.indexOf('MSIE ');\n        if (msie > 0) {\n            // IE 10 or older => return version number\n            return true;\n        }\n        var trident = ua.indexOf('Trident/');\n        if (trident > 0) {\n            // IE 11 => return version number\n            var rv = ua.indexOf('rv:');\n            return true;\n        }\n        var edge = ua.indexOf('Edge/');\n        if (edge > 0) {\n            // Edge (IE 12+) => return version number\n            return true;\n        }\n        // other browser\n        return false;\n    }\n    static isIOS() {\n        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window['MSStream'];\n    }\n    static isAndroid() {\n        return /(android)/i.test(navigator.userAgent);\n    }\n    static appendChild(element, target) {\n        if (this.isElement(target))\n            target.appendChild(element);\n        else if (target.el && target.el.nativeElement)\n            target.el.nativeElement.appendChild(element);\n        else\n            throw 'Cannot append ' + target + ' to ' + element;\n    }\n    static removeChild(element, target) {\n        if (this.isElement(target))\n            target.removeChild(element);\n        else if (target.el && target.el.nativeElement)\n            target.el.nativeElement.removeChild(element);\n        else\n            throw 'Cannot remove ' + element + ' from ' + target;\n    }\n    static isElement(obj) {\n        return (typeof HTMLElement === \"object\" ? obj instanceof HTMLElement :\n            obj && typeof obj === \"object\" && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === \"string\");\n    }\n    static calculateScrollbarWidth(el) {\n        if (el) {\n            let style = getComputedStyle(el);\n            return (el.offsetWidth - el.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth));\n        }\n        else {\n            if (this.calculatedScrollbarWidth !== null)\n                return this.calculatedScrollbarWidth;\n            let scrollDiv = document.createElement(\"div\");\n            scrollDiv.className = \"ui-scrollbar-measure\";\n            document.body.appendChild(scrollDiv);\n            let scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n            document.body.removeChild(scrollDiv);\n            this.calculatedScrollbarWidth = scrollbarWidth;\n            return scrollbarWidth;\n        }\n    }\n    static calculateScrollbarHeight() {\n        if (this.calculatedScrollbarHeight !== null)\n            return this.calculatedScrollbarHeight;\n        let scrollDiv = document.createElement(\"div\");\n        scrollDiv.className = \"ui-scrollbar-measure\";\n        document.body.appendChild(scrollDiv);\n        let scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;\n        document.body.removeChild(scrollDiv);\n        this.calculatedScrollbarWidth = scrollbarHeight;\n        return scrollbarHeight;\n    }\n    static invokeElementMethod(element, methodName, args) {\n        element[methodName].apply(element, args);\n    }\n    static clearSelection() {\n        if (window.getSelection) {\n            if (window.getSelection().empty) {\n                window.getSelection().empty();\n            }\n            else if (window.getSelection().removeAllRanges && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).getClientRects().length > 0) {\n                window.getSelection().removeAllRanges();\n            }\n        }\n        else if (document['selection'] && document['selection'].empty) {\n            try {\n                document['selection'].empty();\n            }\n            catch (error) {\n                //ignore IE bug\n            }\n        }\n    }\n    static getBrowser() {\n        if (!this.browser) {\n            let matched = this.resolveUserAgent();\n            this.browser = {};\n            if (matched.browser) {\n                this.browser[matched.browser] = true;\n                this.browser['version'] = matched.version;\n            }\n            if (this.browser['chrome']) {\n                this.browser['webkit'] = true;\n            }\n            else if (this.browser['webkit']) {\n                this.browser['safari'] = true;\n            }\n        }\n        return this.browser;\n    }\n    static resolveUserAgent() {\n        let ua = navigator.userAgent.toLowerCase();\n        let match = /(chrome)[ \\/]([\\w.]+)/.exec(ua) ||\n            /(webkit)[ \\/]([\\w.]+)/.exec(ua) ||\n            /(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(ua) ||\n            /(msie) ([\\w.]+)/.exec(ua) ||\n            ua.indexOf(\"compatible\") < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua) ||\n            [];\n        return {\n            browser: match[1] || \"\",\n            version: match[2] || \"0\"\n        };\n    }\n    static isInteger(value) {\n        if (Number.isInteger) {\n            return Number.isInteger(value);\n        }\n        else {\n            return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n        }\n    }\n    static isHidden(element) {\n        return element.offsetParent === null;\n    }\n    static getFocusableElements(element) {\n        let focusableElements = DomHandler.find(element, `button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden]), \n                [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden]), \n                input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden]), select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden]), \n                textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden]), [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden]), \n                [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])`);\n        let visibleFocusableElements = [];\n        for (let focusableElement of focusableElements) {\n            if (getComputedStyle(focusableElement).display != \"none\" && getComputedStyle(focusableElement).visibility != \"hidden\")\n                visibleFocusableElements.push(focusableElement);\n        }\n        return visibleFocusableElements;\n    }\n}\nDomHandler.zindex = 1000;\nDomHandler.calculatedScrollbarWidth = null;\nDomHandler.calculatedScrollbarHeight = null;\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DomHandler };\n"]}